# Ключевые архитектурные решения

## 1. Сервисный слой вместо толстых контроллеров

Вся бизнес-логика вынесена в отдельные классы (`RecordRequestService`, `RequestRecordPanelService`). Контроллеры отвечают только за HTTP: приём запроса, вызов сервиса и формирование ответа. Это даёт единую точку ответственности, упрощает тестирование и позволяет переиспользовать логику в командах, очередях или других entry points.

## 2. API Resources для вывода моделей

Модели не отдаются напрямую — всегда через Eloquent API Resources (`RequestRecordResource`). Это гарантирует контролируемую структуру данных на границе, скрывает внутреннюю реализацию и даёт единообразие формата для Inertia и возможного API.

## 3. Фильтрация через AbstractFilter + HasFilter

Фильтрация строится на паре `AbstractFilter` + trait `HasFilter`. Каждая модель получает scope `filter()` через trait, конкретный фильтр (`*Filter`) определяется по имени класса. Список полей и логика — в `$keys` и методах-обработчиках. Подход расширяемый и единообразный для разных сущностей.

## 4. Form Request для валидации

Валидация вынесена в отдельные Form Request классы (`StoreRequest`, `AssignRequest`, `UpdateStatusRequest` и т.д.), а не в контроллер. Это разделяет ответственность, упрощает переиспользование правил и делает контроллеры читаемыми.

## 5. Middleware для проверки переходов статусов

Ограничения доменной логики (кто и при каком статусе может выполнять действие) реализованы в middleware (`EnsureMasterCanStartWork`, `EnsureMasterCanFinish`). Таким образом, проверки прав не размазаны по сервисам и не дублируются — доступ жёстко задан на уровне маршрутов.

## 6. Enum для статусов заявок

Статусы заявок (`RequestRecordStatus`) вынесены в backed enum вместо строк и magic values. Это обеспечивает типобезопасность, автодополнение и единый справочник допустимых состояний во всём коде.

## 7. Ролевая модель через отдельную сущность Role

Роли (`dispatcher`, `master`) вынесены в модель `Role`, а не в enum или конфиг. Так проще добавлять новые роли, привязывать права и поддерживать связь с пользователями через `role_id`. Логика доступа при этом остаётся прозрачной в middleware и сервисах.
